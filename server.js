const express = require('express');
const fs = require('fs');
const path = require('path');
const axios = require('axios');
const TelegramBot = require('node-telegram-bot-api');

const app = express();

let AUCTION_DATA = {};
const CRAFTING_COSTS = {};
const ITEM_COSTS = {};
let NPC_COSTS = {};
let lastUpdated = 0;
let updateInterval = 10000; // 10 —Å–µ–∫—É–Ω–¥ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
let updateIntervalId;
let chatIds = []; // –ú–∞—Å—Å–∏–≤ –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è chatId –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
let minProfit = 0; // –ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è –ø—Ä–∏–±—ã–ª—å –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é

// Telegram Bot Configuration
const telegramBotToken = '7242966791:AAF8ZpBUxwsdItJZloDCh7smGxT90SANOWY';
const bot = new TelegramBot(telegramBotToken, { polling: true });

app.use(express.static('public'));

// Helper function to handle API requests
async function fetchAPI(url) {
  try {
    const response = await axios.get(url);
    return response.data;
  } catch (error) {
    console.error(`–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø—Ä–æ—Å–µ ${url}:`, error.message);
    return null;
  }
}

async function getNumberOfAuctionsPagesAndIfUpdated() {
  const data = await fetchAPI('https://api.hypixel.net/skyblock/auctions');
  if (data) {
    return { numberOfPages: data.totalPages, lastUpdated: data.lastUpdated };
  }
  return { numberOfPages: 0, lastUpdated: lastUpdated };
}

async function getAuctions(page, reforgesList) {
  const data = await fetchAPI(`https://api.hypixel.net/skyblock/auctions?page=${page}`);
  if (data && data.auctions) {
    for (const auction of data.auctions) {
      try {
        if (auction.bin) {
          let name = auction.item_name.toLowerCase();
          name = name.replace(/\[\w*\s\d*\]/g, '')
                     .replace(/\s\s+/g, ' ')
                     .replace(/[^\w\s]\W*$/, '')
                     .replace(/^\W\s/, '')
                     .trim();

          reforgesList.forEach(reforge => {
            const regex = new RegExp(`\\b${reforge}\\b`, 'g');
            name = name.replace(regex, '');
          });
          
          if (name === 'enchanted book') {
            let lore = auction.item_lore;
            let bookNames = lore.split('\n')[0].split(',');
            let legendaryEnchantment = false;

            for (let names of bookNames) {
              let enchantments = names.split('9');
              for (let enchantment of enchantments) {
                if (enchantment.includes('¬ßl')) {
                  name = enchantment.replace(/¬ßd¬ßl¬ß7¬ßl|,|\n/g, '').trim();
                  legendaryEnchantment = true;
                }
              }
              if (!legendaryEnchantment) {
                if (enchantments.length > 1) {
                  name = enchantments[1].replace(/¬ß9¬ßd¬ßl¬ß7¬ßl|,|\n/g, '').trim();
                } else {
                  name = enchantments[0].replace(/¬ß9¬ßd¬ßl¬ß7¬ßl|,|\n/g, '').trim();
                }
              }
            }
            if (name.includes('Use this on') || name.length < 2) {
              continue;
            }
          }

          if (!AUCTION_DATA[name]) {
            AUCTION_DATA[name] = [`${auction.starting_bid}|${auction.uuid}|${auction.end}`];
          } else {
            AUCTION_DATA[name].push(`${auction.starting_bid}|${auction.uuid}|${auction.end}`);
          }
        }
      } catch (e) {
        console.error('–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∞—É–∫—Ü–∏–æ–Ω–∞:', e.message);
      }
    }
  }
}

async function getBazaarPrices() {
  const data = await fetchAPI('https://api.hypixel.net/skyblock/bazaar');
  if (data && data.products) {
    for (let key in data.products) {
      const item = data.products[key];
      const buyPrice = item.buy_summary.length ? item.buy_summary[0].pricePerUnit : 0;
      const sellPrice = item.sell_summary.length ? item.sell_summary[0].pricePerUnit : 0;
      ITEM_COSTS[key] = { buyPrice, sellPrice };
    }
  }
}

async function getNPCPrices() {
  const data = await fetchAPI('https://api.hypixel.net/skyblock/npc');
  if (data && data.npcs) {
    let npcPrices = {};
    for (const npc of data.npcs) {
      npcPrices[npc.item] = npc.price;
    }
    return npcPrices;
  }
  return {};
}

async function calculateCraftingCosts(recipes) {
  for (let item in recipes) {
    let totalCost = 0;
    for (let ingredient of recipes[item]) {
      const itemCost = ITEM_COSTS[ingredient.name] ? ITEM_COSTS[ingredient.name].buyPrice : (NPC_COSTS[ingredient.name] || 0);
      totalCost += itemCost * ingredient.quantity;
    }
    CRAFTING_COSTS[item] = totalCost;
  }
}

function findItemsToFlip(data) {
  let flipItems = {};

  for (let [key, value] of Object.entries(data)) {
    let product = value.map(item => parseFloat(item.split('|')[0])).filter(p => !isNaN(p));
    let productsUuid = value.map(item => item.split('|')[1]).filter(uuid => uuid !== null);

    if (product.every(p => p === product[0])) {
      continue;
    }

    let productNormalize = product.map(p => (p - Math.min(...product)) / (Math.max(...product) - Math.min(...product)));

    if (product.length > 1) {
      let [madZscore, mad] = MAD_Z_Score(productNormalize);

      let productMedian = product.reduce((a, b) => a + b, 0) / product.length;
      let productAnomalies = madZscore.map(score => score > 3);

      if (productAnomalies.filter(Boolean).length < 3) {
        let productSorted = [...product].sort((a, b) => a - b);
        for (let idx in productAnomalies) {
          if (productAnomalies[idx] && product[idx] < productMedian) {
            let outlier = product[idx];
            productSorted = productSorted.filter(p => p !== outlier);
            let cheapest = productSorted[0];
            let expensive = Math.max(...productSorted);
            let expectedProfit = expensive - cheapest;

            if (expectedProfit > minProfit) { // –§–∏–ª—å—Ç—Ä –ø–æ –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–π –ø—Ä–∏–±—ã–ª–∏
              flipItems[key] = [outlier, cheapest, expectedProfit, product.length, productsUuid[idx]];
              notifyTelegram(key, expectedProfit, outlier, cheapest, productsUuid[idx]);
            }
          }
        }
      }
    }
  }

  AUCTION_DATA.flipItems = Object.entries(flipItems).map(([key, value]) => ({
    'Item Name': key,
    'Hunted Price': formatNumber(value[0]),
    'LBin': formatNumber(value[1]),
    'Expected Profit': formatNumber(value[2]),
    'Items on market': value[3],
    'Auction uuid': value[4],
  })).sort((a, b) => b['Expected Profit'] - a['Expected Profit']);
}

function MAD_Z_Score(data, consistencyCorrection = 1.4826) {
  let median = data.reduce((a, b) => a + b, 0) / data.length;
  let deviationFromMed = data.map(d => Math.abs(d - median));
  let MAD = deviationFromMed.reduce((a, b) => a + b, 0) / deviationFromMed.length;

  if (MAD !== 0) {
    let MAD_zscore = deviationFromMed.map(d => d / (consistencyCorrection * MAD));
    return [MAD_zscore, MAD];
  } else {
    return [Array(data.length).fill(0), 0];
  }
}

function formatNumber(num) {
  return new Intl.NumberFormat().format(num);
}

function writeDataToCSV(data, filename) {
  const filePath = path.join(__dirname, filename);
  const headers = Object.keys(data[0]).join(',');
  const rows = data.map(item => Object.values(item).join(','));

  const csvContent = [headers, ...rows].join('\n');
  fs.writeFileSync(filePath, csvContent, 'utf8');
}

async function fetchAllItemPrices() {
  await getBazaarPrices();
  NPC_COSTS = await getNPCPrices();

  let recipes = {}; // –î–æ–ª–∂–Ω—ã –±—ã—Ç—å –∑–∞–≥—Ä—É–∂–µ–Ω—ã –æ—Ç–∫—É–¥–∞-—Ç–æ
  await calculateCraftingCosts(recipes);

  let combinedData = [];
  for (const item in ITEM_COSTS) {
    const npcCost = NPC_COSTS[item] || 0;
    const craftingCost = CRAFTING_COSTS[item] || 0;
    const buyPrice = ITEM_COSTS[item].buyPrice;
    const sellPrice = ITEM_COSTS[item].sellPrice;

    combinedData.push({
      'Item Name': item,
      'NPC Cost': npcCost,
      'Crafting Cost': craftingCost,
      'Bazaar Buy Price': buyPrice,
      'Bazaar Sell Price': sellPrice
    });
  }

  writeDataToCSV(combinedData, 'item_prices.csv');
}

async function processAuctions() {
  let pageData = await getNumberOfAuctionsPagesAndIfUpdated();
  if (pageData.lastUpdated > lastUpdated) {
    AUCTION_DATA = {};
    for (let page = 0; page < pageData.numberOfPages; page++) {
      await getAuctions(page, []); // –ó–∞–º–µ–Ω–∏ [] –Ω–∞ —Å–ø–∏—Å–æ–∫ —Ä–µ—Ñ–æ–¥–∂–µ–≤
    }
    findItemsToFlip(AUCTION_DATA);
    lastUpdated = pageData.lastUpdated;
  }
}

function notifyTelegram(item, profit, outlier, cheapest, uuid) {
  const message = `üéØ **Item Name:** ${item}\nüìâ **Hunted Price:** ${formatNumber(outlier)}\nüí∞ **LBin:** ${formatNumber(cheapest)}\nüìà **Expected Profit:** ${formatNumber(profit)}\nüîó **Auction UUID:** ${uuid}`;
  chatIds.forEach(chatId => bot.sendMessage(chatId, message, { parse_mode: 'Markdown' }));
}

bot.onText(/\/start/, (msg) => {
  const chatId = msg.chat.id;
  if (!chatIds.includes(chatId)) {
    chatIds.push(chatId);
  }
  bot.sendMessage(chatId, '–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å! –ü–æ–¥–ø–∏—Å–∫–∞ –Ω–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω–∞.');
});

bot.onText(/\/help/, (msg) => {
  const chatId = msg.chat.id;
  const helpMessage = `–ü—Ä–∏–≤–µ—Ç! –í–æ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã:
/start - –ü–æ–¥–ø–∏—Å–∞—Ç—å—Å—è –Ω–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è
/help - –ü–æ–∫–∞–∑–∞—Ç—å —ç—Ç–æ —Å–æ–æ–±—â–µ–Ω–∏–µ
/status - –ü—Ä–æ–≤–µ—Ä–∏—Ç—å —Å—Ç–∞—Ç—É—Å –±–æ—Ç–∞
/update - –û–±–Ω–æ–≤–∏—Ç—å –¥–∞–Ω–Ω—ã–µ –∏ –∑–∞–ø—É—Å—Ç–∏—Ç—å –ø—Ä–æ—Ü–µ—Å—Å –ø–æ–∏—Å–∫–∞ –∞—É–∫—Ü–∏–æ–Ω–æ–≤
/list - –ü–æ–∫–∞–∑–∞—Ç—å —Å–ø–∏—Å–æ–∫ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –ø—Ä–µ–¥–º–µ—Ç–æ–≤ –∏ –∏—Ö —Ü–µ–Ω
/flip - –ü–æ–∫–∞–∑–∞—Ç—å –Ω–∞–∏–±–æ–ª–µ–µ –≤—ã–≥–æ–¥–Ω—ã–µ –ø—Ä–µ–¥–º–µ—Ç—ã –¥–ª—è –ø–æ–∫—É–ø–∫–∏ –∏ –ø–µ—Ä–µ–ø—Ä–æ–¥–∞–∂–∏
/interval - –£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –∏–Ω—Ç–µ—Ä–≤–∞–ª –æ–±–Ω–æ–≤–ª–µ–Ω–∏–π –¥–∞–Ω–Ω—ã—Ö (–≤ –º–∏–ª–ª–∏—Å–µ–∫—É–Ω–¥–∞—Ö)
/startinterval - –ó–∞–ø—É—Å—Ç–∏—Ç—å –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö
/stopinterval - –û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö
/minprofit - –£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –º–∏–Ω–∏–º–∞–ª—å–Ω—É—é –ø—Ä–∏–±—ã–ª—å –¥–ª—è —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏`;
  bot.sendMessage(chatId, helpMessage);
});

bot.onText(/\/status/, (msg) => {
  const chatId = msg.chat.id;
  const statusMessage = `–ë–æ—Ç –∞–∫—Ç–∏–≤–µ–Ω. –ü–æ—Å–ª–µ–¥–Ω–µ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –ø—Ä–æ–∏–∑–æ—à–ª–æ: ${new Date(lastUpdated).toLocaleString()}.`;
  bot.sendMessage(chatId, statusMessage);
});

bot.onText(/\/update/, async (msg) => {
  const chatId = msg.chat.id;
  try {
    await fetchAllItemPrices();
    await processAuctions();
    bot.sendMessage(chatId, '–î–∞–Ω–Ω—ã–µ –æ–±–Ω–æ–≤–ª–µ–Ω—ã –∏ –ø—Ä–æ—Ü–µ—Å—Å –ø–æ–∏—Å–∫–∞ –∞—É–∫—Ü–∏–æ–Ω–æ–≤ –∑–∞–ø—É—â–µ–Ω.');
  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö:', error.message);
    bot.sendMessage(chatId, '–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –¥–∞–Ω–Ω—ã—Ö.');
  }
});

bot.onText(/\/list/, (msg) => {
  const chatId = msg.chat.id;
  const itemsList = Object.keys(AUCTION_DATA).map(item => `‚Ä¢ ${item}`).join('\n');
  bot.sendMessage(chatId, `–î–æ—Å—Ç—É–ø–Ω—ã–µ –ø—Ä–µ–¥–º–µ—Ç—ã:\n${itemsList}`);
});

bot.onText(/\/flip/, (msg) => {
  const chatId = msg.chat.id;
  const flipItemsList = AUCTION_DATA.flipItems || [];
  if (flipItemsList.length > 0) {
    const message = flipItemsList.map(item => `üéØ **Item Name:** ${item['Item Name']}\nüìâ **Hunted Price:** ${item['Hunted Price']}\nüí∞ **LBin:** ${item['LBin']}\nüìà **Expected Profit:** ${item['Expected Profit']}\nüîó **Auction UUID:** ${item['Auction uuid']}`).join('\n\n');
    bot.sendMessage(chatId, `**–ù–∞–∏–±–æ–ª–µ–µ –≤—ã–≥–æ–¥–Ω—ã–µ –ø—Ä–µ–¥–º–µ—Ç—ã –¥–ª—è –ø–æ–∫—É–ø–∫–∏ –∏ –ø–µ—Ä–µ–ø—Ä–æ–¥–∞–∂–∏:**\n\n${message}`, { parse_mode: 'Markdown' });
  } else {
    bot.sendMessage(chatId, '–ù–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –ø—Ä–µ–¥–º–µ—Ç–æ–≤ –¥–ª—è –ø–µ—Ä–µ–ø—Ä–æ–¥–∞–∂–∏ –≤ –¥–∞–Ω–Ω—ã–π –º–æ–º–µ–Ω—Ç.');
  }
});

bot.onText(/\/interval (.+)/, (msg, match) => {
  const chatId = msg.chat.id;
  const interval = parseInt(match[1], 10);
  if (!isNaN(interval) && interval > 0) {
    updateInterval = interval;
    bot.sendMessage(chatId, `–ò–Ω—Ç–µ—Ä–≤–∞–ª –æ–±–Ω–æ–≤–ª–µ–Ω–∏–π —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –Ω–∞ ${interval} –º–∏–ª–ª–∏—Å–µ–∫—É–Ω–¥.`);
  } else {
    bot.sendMessage(chatId, '–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —É–∫–∞–∂–∏—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –∏–Ω—Ç–µ—Ä–≤–∞–ª–∞ –≤ –º–∏–ª–ª–∏—Å–µ–∫—É–Ω–¥–∞—Ö.');
  }
});

bot.onText(/\/startinterval/, (msg) => {
  const chatId = msg.chat.id;
  if (updateIntervalId) {
    bot.sendMessage(chatId, '–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —É–∂–µ –∑–∞–ø—É—â–µ–Ω–æ.');
    return;
  }
  updateIntervalId = setInterval(async () => {
    try {
      await fetchAllItemPrices();
      await processAuctions();
    } catch (error) {
      console.error('–û—à–∏–±–∫–∞ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è:', error.message);
    }
  }, updateInterval);
  bot.sendMessage(chatId, '–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –∑–∞–ø—É—â–µ–Ω–æ.');
});

bot.onText(/\/stopinterval/, (msg) => {
  const chatId = msg.chat.id;
  if (updateIntervalId) {
    clearInterval(updateIntervalId);
    updateIntervalId = null;
    bot.sendMessage(chatId, '–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ.');
  } else {
    bot.sendMessage(chatId, '–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –Ω–µ –∑–∞–ø—É—â–µ–Ω–æ.');
  }
});

bot.onText(/\/minprofit (.+)/, (msg, match) => {
  const chatId = msg.chat.id;
  const profit = parseFloat(match[1]);
  if (!isNaN(profit) && profit >= 0) {
    minProfit = profit;
    bot.sendMessage(chatId, `–ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è –ø—Ä–∏–±—ã–ª—å —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞ –Ω–∞ ${formatNumber(profit)}.`);
  } else {
    bot.sendMessage(chatId, '–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —É–∫–∞–∂–∏—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–π –ø—Ä–∏–±—ã–ª–∏.');
  }
});

app.listen(3000, () => {
  
});
